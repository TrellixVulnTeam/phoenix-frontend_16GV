"use strict";
// Copyright 2022 Google LLC
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepare = void 0;
const path_1 = require("path");
const process_1 = require("process");
const firebase_1 = require("./firebase");
const frameworks_1 = require("./frameworks");
const utils_1 = require("./utils");
const prepare = (targetNames, context, options) => __awaiter(void 0, void 0, void 0, function* () {
    let startBuildQueue;
    let buildQueue = new Promise((resolve) => startBuildQueue = resolve);
    yield (0, firebase_1.getFirebaseTools)();
    const configs = (0, firebase_1.getNormalizedHostingConfig)()(options, { resolveTargets: true });
    if (configs.length === 0)
        return;
    configs.forEach(({ source, site, target, public: publicDir }) => {
        if (!source)
            return;
        const dist = (0, path_1.join)(process.cwd(), '.firebase', site);
        const hostingDist = (0, path_1.join)('.firebase', site, 'hosting');
        const functionsDist = (0, path_1.join)('.firebase', site, 'functions');
        if (publicDir)
            throw `hosting.public and hosting.source cannot both be set in firebase.json`;
        const getProjectPath = (...args) => (0, path_1.join)(process.cwd(), source, ...args);
        const functionName = `ssr${site.replace(/-/g, '')}`;
        buildQueue = buildQueue.then(results => (0, frameworks_1.build)({
            dist,
            project: context.project,
            site,
            // TODO refactor to skip the function build step, if unneeded
            function: {
                name: functionName,
                region: utils_1.DEFAULT_REGION,
                gen: 2,
            },
        }, getProjectPath).then(result => (results.push(Object.assign(Object.assign({}, result), { functionName, site, target, hostingDist, functionsDist })), results)));
    });
    startBuildQueue([]);
    const results = yield buildQueue;
    const hostingConfig = options.config.get('hosting');
    yield Promise.all(results.map(({ usingCloudFunctions, hostingDist, site, target, functionsDist, functionName }) => __awaiter(void 0, void 0, void 0, function* () {
        const hostingIndex = Array.isArray(hostingConfig) ? `[${hostingConfig.findIndex((it) => it.site === site || it.target === target)}]` : '';
        options.config.set(`hosting${hostingIndex}.public`, hostingDist);
        const rewrites = options.config.get(`hosting${hostingIndex}.rewrites`) || [];
        if (usingCloudFunctions) {
            if (context.hostingChannel) {
                // TODO move to prompts
                const message = 'Cannot preview changes to the backend, you will only see changes to the static content on this channel.';
                if (!options.nonInteractive) {
                    const { continueDeploy } = yield (0, firebase_1.getInquirer)().prompt({
                        type: 'confirm',
                        name: 'continueDeploy',
                        message: `${message} Would you like to continue with the deploy?`,
                        default: true,
                    });
                    if (!continueDeploy)
                        (0, process_1.exit)(1);
                }
                else {
                    console.error(message);
                }
            }
            else {
                const functionConfig = {
                    source: functionsDist,
                    codebase: `firebase-frameworks-${site}`,
                };
                if (targetNames.includes('functions')) {
                    const combinedFunctionsConfig = [functionConfig].concat(options.config.get('functions') || []);
                    options.config.set('functions', combinedFunctionsConfig);
                }
                else {
                    targetNames.unshift('functions');
                    options.config.set('functions', functionConfig);
                }
            }
            // TODO get the other firebase.json modifications
            options.config.set(`hosting${hostingIndex}.rewrites`, [...rewrites, {
                    source: '**',
                    function: functionName,
                }]);
        }
        else {
            options.config.set(`hosting${hostingIndex}.rewrites`, [...rewrites, {
                    source: '**',
                    destination: '/index.html',
                }]);
        }
    })));
});
exports.prepare = prepare;
