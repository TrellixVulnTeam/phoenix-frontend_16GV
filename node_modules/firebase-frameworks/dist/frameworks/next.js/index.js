"use strict";
// Copyright 2022 Google LLC
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const templates_1 = require("./templates");
const utils_1 = require("../../utils");
const firebase_1 = require("../../firebase");
const { readFile, rm, mkdir, writeFile, copyFile } = fs_1.promises;
const build = (config, getProjectPath) => __awaiter(void 0, void 0, void 0, function* () {
    const { default: nextBuild } = require(getProjectPath('node_modules', 'next', 'dist', 'build'));
    yield nextBuild(getProjectPath(), null, false, false, true);
    // TODO be a bit smarter about this
    yield (0, utils_1.exec)(`${getProjectPath('node_modules', '.bin', 'next')} export`, { cwd: getProjectPath() }).catch(() => { });
    let nextConfig;
    try {
        const { default: loadConfig } = require(getProjectPath('node_modules', 'next', 'dist', 'server', 'config'));
        const { PHASE_PRODUCTION_BUILD } = require(getProjectPath('node_modules', 'next', 'constants'));
        nextConfig = yield loadConfig(PHASE_PRODUCTION_BUILD, getProjectPath(), null);
    }
    catch (e) {
        // Must be Next 11, just import it
        nextConfig = yield Promise.resolve().then(() => __importStar(require(getProjectPath('next.config.js'))));
    }
    // SEMVER these defaults are only needed for Next 11
    const { distDir = '.next', basePath = '' } = nextConfig;
    const deployPath = (...args) => config.dist ? (0, path_1.join)(config.dist, ...args) : getProjectPath('.deploy', ...args);
    const getHostingPath = (...args) => deployPath('hosting', ...basePath.split('/'), ...args);
    yield rm(deployPath(), { recursive: true, force: true });
    yield mkdir(getHostingPath('_next', 'static'), { recursive: true });
    let needsCloudFunction = !!config.function;
    const asyncSteps = [];
    const exportDetailJson = yield readFile(getProjectPath(distDir, 'export-detail.json')).then(it => JSON.parse(it.toString()), () => { success: false; });
    if (exportDetailJson.success) {
        needsCloudFunction = false;
        asyncSteps.push((0, utils_1.exec)(`cp -r ${exportDetailJson.outDirectory}/* ${getHostingPath()}`));
    }
    else {
        yield (0, utils_1.exec)(`cp -r ${getProjectPath('public')}/* ${getHostingPath()}`);
        yield (0, utils_1.exec)(`cp -r ${getProjectPath(distDir, 'static')} ${getHostingPath('_next')}`);
        // TODO clean this up, probably conflicts with the code blow
        const serverPagesDir = getProjectPath(distDir, 'server', 'pages');
        const htmlFiles = (yield (0, utils_1.exec)(`find ${serverPagesDir} -name '*.html'`)).split("\n").map(it => it.trim());
        yield Promise.all(htmlFiles.map((path) => __awaiter(void 0, void 0, void 0, function* () {
            const newPath = getHostingPath((0, path_1.relative)(serverPagesDir, path));
            yield mkdir((0, path_1.dirname)(newPath), { recursive: true });
            yield copyFile(path, newPath);
        })));
        const prerenderManifestBuffer = yield readFile(getProjectPath(distDir, 'prerender-manifest.json'));
        const prerenderManifest = JSON.parse(prerenderManifestBuffer.toString());
        Object.keys(prerenderManifest.routes).forEach(route => {
            // / => index.json => index.html => index.html
            // /foo => foo.json => foo.html
            const parts = route.split('/').slice(1).filter(it => !!it);
            const partsOrIndex = parts.length > 0 ? parts : ['index'];
            const dataPath = `${(0, path_1.join)(...partsOrIndex)}.json`;
            const htmlPath = `${(0, path_1.join)(...partsOrIndex)}.html`;
            const moveHTML = mkdir(getHostingPath((0, path_1.dirname)(htmlPath)), { recursive: true }).then(() => {
                return copyFile(getProjectPath(distDir, 'server', 'pages', htmlPath), getHostingPath(htmlPath));
            });
            const dataRoute = prerenderManifest.routes[route].dataRoute;
            const moveData = mkdir(getHostingPath((0, path_1.dirname)(dataRoute)), { recursive: true }).then(() => {
                return copyFile(getProjectPath(distDir, 'server', 'pages', dataPath), getHostingPath(dataRoute));
            });
            // TODO initialRevalidateSeconds should be used in Cloud Fuctions as a c-max-age
            asyncSteps.push(moveHTML);
            asyncSteps.push(moveData);
        });
    }
    if (needsCloudFunction) {
        yield mkdir(deployPath('functions'), { recursive: true });
        asyncSteps.push(copyFile(getProjectPath('next.config.js'), deployPath('functions', 'next.config.js')), (0, utils_1.exec)(`cp -r ${getProjectPath('public')} ${deployPath('functions', 'public')}`), (0, utils_1.exec)(`cp -r ${getProjectPath(distDir)} ${deployPath('functions', distDir)}`));
    }
    const packageJsonBuffer = yield readFile(getProjectPath('package.json'));
    const packageJson = JSON.parse(packageJsonBuffer.toString());
    let firebaseProjectConfig = null;
    const { project, site } = config;
    if (project && site) {
        // TODO check if firebase/auth is used
        const hasFirebaseDependency = !!packageJson.dependencies.firebase;
        if (needsCloudFunction && hasFirebaseDependency) {
            const firebaseTools = yield (0, firebase_1.getFirebaseTools)();
            const { sites } = yield firebaseTools.hosting.sites.list(Object.assign({ project }, (0, utils_1.defaultFirebaseToolsOptions)(deployPath())));
            const selectedSite = sites.find(it => (0, utils_1.shortSiteName)(it) === site);
            if (selectedSite) {
                const { appId } = selectedSite;
                if (appId) {
                    const result = yield firebaseTools.apps.sdkconfig('web', appId, (0, utils_1.defaultFirebaseToolsOptions)(deployPath()));
                    firebaseProjectConfig = result.sdkConfig;
                }
                else {
                    console.warn(`No Firebase app associated with site ${site}, unable to provide authenticated server context`);
                }
            }
        }
    }
    if (needsCloudFunction) {
        asyncSteps.push(copyFile(getProjectPath('package-lock.json'), deployPath('functions', 'package-lock.json')).catch(() => { }), copyFile(getProjectPath('yarn.lock'), deployPath('functions', 'yarn.lock')).catch(() => { }), writeFile(deployPath('functions', 'package.json'), (0, templates_1.newPackageJson)(packageJson)), writeFile(deployPath('functions', 'server.js'), (0, templates_1.newServerJs)(config, firebaseProjectConfig)));
    }
    yield Promise.all(asyncSteps);
    if (needsCloudFunction) {
        // TODO add to the firebaseTools log
        yield (0, utils_1.spawn)('npm', ['i', '--prefix', deployPath('functions'), '--only', 'production', '--no-audit', '--no-fund', '--silent'], {}, stdoutChunk => {
            console.log(stdoutChunk.toString());
        }, errChunk => {
            console.error(errChunk.toString());
        });
    }
    return { usingCloudFunctions: needsCloudFunction };
});
exports.build = build;
